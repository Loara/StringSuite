/*
    This file is part of Encmetric.
    Copyright (C) 2021 Paolo De Donato.

    Encmetric is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Encmetric is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with Encmetric. If not, see <http://www.gnu.org/licenses/>.
*/

extern "C"{
#include <windows.h>
}
#include <strsuite/encmetric/enc_c.hpp>
#include <strsuite/io/enc_io_core.hpp>
#include <strsuite/io/enc_io_buffer.hpp>

using namespace sts::literals;

size_t sts::def_strlen(const sts::byte *b){
    int i = lstrlenW(reinterpret_cast<LPCWSTR>(b));
    if(i >= 0)
        return static_cast<size_t>(i);
    else
        throw sts::IOFail{};
}

struct Windows_syscalls{
    HANDLE fd;
    Windows_syscalls(HANDLE f) : fd{f} {}

    static constexpr size_t buffer_size=64;

    size_t read_wrap(sts::byte *v, size_t l){
        DWORD chrr;
        auto err = ReadConsoleW(fd, v, l/2, &chrr, NULL);
        if(err == 0){
            auto errnoo = GetLastError();
            if(errnoo == ERROR_IO_PENDING)
                throw sts::IOAGAIN{};
            else
                throw sts::IOFail{};
        }
        else if(chrr == 0)
            throw sts::IOEOF{};
        return 2 * static_cast<size_t>(chrr);
    }
    size_t write_wrap(const sts::byte *v, size_t l){
        DWORD chrr;
        auto err = WriteConsoleW(fd, v, l/2, &chrr, NULL);
        if(err == 0){
            auto errnoo = GetLastError();
            if(errnoo == ERROR_IO_PENDING)
                throw sts::IOAGAIN{};
            else
                throw sts::IOFail{};
        }
        else if(chrr == 0)
            throw sts::IOEOF{};
        return 2 * static_cast<size_t>(chrr);
        /*
        ssize_t wt = write(fd, v, l);
        if(wt < 0){
            switch(errno){
                case EAGAIN:
                case_EWOULDBLOCK
                    throw sts::IOAGAIN{};
                case EINTR:
                    repeat = true;
                    return 0;
                case EDQUOT:
                case EFBIG:
                    throw sts::IOEOF{};
                default:
                    throw sts::IOFail{};
            }
        }
        else if(wt == 0)
            throw sts::IOEOF{};
        return static_cast<size_t>(wt);
        */
    }
};


class Windows_istream : public sts::InputStream{
    private:
        sts::istr_buffer<sts::UTF16LE, Windows_syscalls> buffer;
        static_assert(Windows_syscalls::buffer_size > 4, "buffer too small");
    protected:
        sts::adv_string_view<sts::UTF16LE> do_newline() const noexcept{ return u"\r\n"_asv;}
        sts::uint do_char_read(sts::tchar_pt<sts::UTF16LE> pt, size_t siz){
            sts::EncMetric_info<sts::UTF16LE> format{};
            if(siz < 2)
                throw sts::IOBufsmall{2-siz};
            sts::uint totl = buffer.get_chLen(format);
            if(siz < static_cast<size_t>(totl))
                throw sts::IOBufsmall{static_cast<size_t>(totl) - siz};
            std::memcpy(pt.data(), buffer.base + buffer.fir, totl);
            buffer.raw_fir_step(totl);
            return totl;
        }
        sts::uint do_ghost_read(sts::tchar_pt<sts::UTF16LE> pt, size_t siz){
            if(siz < 2)
                throw sts::IOBufsmall{2-siz};
            sts::EncMetric_info<sts::UTF16LE> format{};
            sts::uint totl = buffer.get_chLen(format);
            if(siz < static_cast<size_t>(totl))
                throw sts::IOBufsmall{static_cast<size_t>(totl) - siz};
            std::memcpy(pt.data(), buffer.base + buffer.fir, totl);
            return totl;
        }

        void do_close() {}

        void do_discard(){
            sts::byte rc[] = {sts::byte{0x0d}, sts::byte{0x00}};
            sts::byte nl[] = {sts::byte{0x0a}, sts::byte{0x00}};
            sts::byte buf[4];
            sts::tchar_pt<sts::UTF16LE> o{buf};
            bool hr=false, hn=false;
            do{
                try{
                    do_char_read(o, 4);
                }
                catch(...){
                    return;
                }
                if(buf[0] == rc[0] && buf[1] == rc[1])
                    hr = true;
                else if(hr && buf[0] == nl[0] && buf[1] == nl[1])
                    hn = true;
                else{
                    hr = false;
                    hn= false;
                }
            }
            while(!hr || !hn);
        }


        sts::EncMetric_info<sts::UTF16LE> do_encmetric() const noexcept{ return sts::EncMetric_info<sts::UTF16LE>{};}
    public:
        Windows_istream () : buffer{Windows_syscalls{GetStdHandle(STD_INPUT_HANDLE)}} {}
};

class Windows_ostream : public sts::OutputStream{
    private:
        sts::ostr_buffer<sts::UTF16LE, Windows_syscalls> buffer;
        static_assert(Windows_syscalls::buffer_size > 4, "buffer too small");
    protected:
        sts::adv_string_view<sts::UTF16LE> do_newline() const noexcept{ return u"\r\n"_asv;}
        sts::uint do_char_write(sts::const_tchar_pt<sts::UTF16LE> pt, size_t siz){
            if(siz < 2)
                throw sts::IOBufsmall{2-siz};
            sts::uint totl = pt.chLen(siz);
            if(totl > siz)
                throw sts::IOBufsmall{totl-siz};
            buffer.force_frspc(totl);
            std::memcpy(buffer.base + buffer.las, pt.data(), totl);
            buffer.raw_las_step(totl);
            return totl;
        }
        size_t do_string_write(const sts::adv_string_view<sts::UTF16LE> &str){
            size_t rem = str.size();
            const sts::byte *b = str.data();
            while(rem > 0){
                sts::size_t wrt = buffer.req_frspc(rem);
                std::memcpy(buffer.base + buffer.las, b, wrt);
                buffer.raw_las_step(wrt);
                rem -= wrt;
            }
            return str.size();
        }

        void do_close() {}

        void do_flush(){
            buffer.flush();
        }

        sts::EncMetric_info<sts::UTF16LE> do_encmetric() const noexcept{ return sts::EncMetric_info<sts::UTF16LE>{};}
    public:
        Windows_ostream (HANDLE f) : buffer{Windows_syscalls{f}} {}
};

InputStream &sts::get_console_stdin(){
    static Windows_istream input{};
    return input;
}

OutputStream &sts::get_console_stdout(){
    static Windows_ostream input{GetStdHandle(STD_OUTPUT_HANDLE)};
    return input;
}

OutputStream &sts::get_console_stderr(){
    static Windows_ostream input{GetStdHandle(STD_ERROR_HANDLE)};
    return input;
}

sts::param_helper::param_helper(int, const char **) : argn{0}, args{nullptr} {
    auto pointer = GetCommandLineW();
    auto ret = CommandLineToArgvW(pointer, &argn);
    args = const_cast<const sts::byte **>(reinterpret_cast<sts::byte **>(ret));
}

sts::param_helper::~param_helper() {
    LocalFree(args);
}

