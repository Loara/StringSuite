extern "C"{
#include <windows.h>
}
#include <strsuite/encmetric/base.hpp>
#include <strsuite/io/enc_io_core.hpp>

size_t sts::def_strlen(const sts::byte *b){
    int i = lstrlenW(reinterpret_cast<LPCWSTR>(b));
    if(i >= 0)
        return static_cast<size_t>(i);
    else
        throw sts::IOFail{};
}


class in_buffer : private sts::stat_buf<64>{
    private:
        HANDLE fd;
        void refresh_empty(){
            if(siz != 0)
                return;
            fir=0;
            DWORD chrr;
            auto err = ReadConsoleW(fd, raw_last(), raw_contiguous_last()/2, &chrr, NULL);
            if(err == 0){
                auto errnoo = GetLastError();
                if(errnoo == ERROR_IO_PENDING)
                    throw sts::IOAGAIN{};
                else
                    throw sts::IOFail{};
            }
            else if(chrr == 0)
                throw sts::IOEOF{};
            raw_set(2 * static_cast<size_t>(chrr));
        }
    public:
        /*
         * Read exactly len bytes, throw exception (IOEOF for example) if there are less
         */
        void copy_to(sts::byte *to, size_t len){
            //even
            len = len - (len % 2);
            sts::byte *inc = to;
            while(len > 0){
                size_t buf_wrt = raw_contiguous_first();
                if(buf_wrt > 0){
                    size_t min = buf_wrt > len ? len : buf_wrt;
                    std::memcpy(inc, raw_first(), min);
                    inc += min;
                    raw_get(min);
                    len -= min;
                }
                else
                    refresh_empty();
            }
        }
        /*
         * don't remove that byte from buffer
         */
        void test_byte(sts::byte *to){
            if(siz == 0)
                refresh_empty();
            to[0] = *raw_first();
            to[1] = *(raw_first()+1);
        }

        in_buffer(HANDLE f) : fd{f} {}
};

class out_buffer : private sts::stat_buf<64> {
    private:
        HANDLE fd;
    public:
        void svuota(){
            while(raw_contiguous_first() > 0){
                DWORD chrr;
                auto err = WriteConsoleW(fd, raw_first(), raw_contiguous_first()/2, &chrr, NULL);
                if(err == 0){
                    auto errnoo = GetLastError();
                    if(errnoo == ERROR_IO_PENDING)
                        throw sts::IOAGAIN{};
                    else
                        throw sts::IOFail{};
                }
                else if(chrr == 0)
                    throw sts::IOEOF{};
                raw_get(2 * static_cast<size_t>(chrr));
            }
        }
        /*
         * Read exactly len bytes, throw exception (IOEOF for example) if there are less
         */
        void copy_from(const sts::byte *to, size_t len){
            const sts::byte *inc = to;
            while(len > 0){
                size_t buf_wrt = raw_contiguous_last();
                if(buf_wrt > 0){
                    size_t min = buf_wrt > len ? len : buf_wrt;
                    std::memcpy(raw_last(), inc, min);
                    inc += min;
                    raw_set(min);
                    len -= min;
                }
                else
                    svuota();
            }
        }

        out_buffer(HANDLE f) : fd{f} {}
};

class Windows_istream : public sts::CharIStream<sts::UTF16LE>{
    private:
        in_buffer buffer;
    protected:
        sts::uint do_char_read(sts::tchar_pt<sts::UTF16LE> pt, size_t siz){
            if(siz == 0)
                return 0;
            sts::byte cht[2];
            buffer.test_byte(cht);
            sts::uint totl = sts::UTF16LE::chLen(cht, 2);
            if(totl > siz)
                throw sts::IOBufsmall{};
            buffer.copy_to(pt.data(), totl);
            return totl;
        }

        void do_close() {}

        void do_flush(){
            sts::byte rc[] = {sts::byte{0x0d}, sts::byte{0x00}};
            sts::byte nl[] = {sts::byte{0x0a}, sts::byte{0x00}};
            sts::byte buf[4];
            sts::tchar_pt<sts::UTF16LE> o{buf};
            bool hr=false, hn=false;
            do{
                try{
                    do_char_read(o, 4);
                }
                catch(...){
                    return;
                }
                if(buf[0] == rc[0] && buf[1] == rc[1])
                    hr = true;
                else if(hr && buf[0] == nl[0] && buf[1] == nl[1])
                    hn = true;
                else{
                    hr = false;
                    hn= false;
                }
            }
            while(!hr || !hn);
        }

        sts::EncMetric_info<sts::UTF16LE> do_encmetric() const noexcept{ return sts::EncMetric_info<sts::UTF16LE>{};}
    public:
        Windows_istream () : buffer{GetStdHandle(STD_INPUT_HANDLE)} {}
};

class Windows_ostream : public sts::CharOStream<sts::UTF16LE>{
    private:
        out_buffer buffer;
    protected:
        sts::uint do_char_write(sts::const_tchar_pt<sts::UTF16LE> pt, size_t siz){
            if(siz == 0)
                return 0;
            sts::uint totl = pt.chLen(siz);
            if(totl > siz)
                throw sts::IOBufsmall{};
            buffer.copy_from(pt.data(), totl);
            return totl;
        }

        void do_close() {}

        void do_flush(){
            buffer.svuota();
        }

        sts::EncMetric_info<sts::UTF16LE> do_encmetric() const noexcept{ return sts::EncMetric_info<sts::UTF16LE>{};}
    public:
        Windows_ostream (HANDLE f) : buffer{f} {}
};

sts::CharIStream<sts::UTF16LE> *sts::get_console_stdin(){
    static Windows_istream input{};
    return &input;
}

sts::CharOStream<sts::UTF16LE> *sts::get_console_stdout(){
    static Windows_ostream input{GetStdHandle(STD_OUTPUT_HANDLE)};
    return &input;
}

sts::CharOStream<sts::UTF16LE> *sts::get_console_stderr(){
    static Windows_ostream input{GetStdHandle(STD_ERROR_HANDLE)};
    return &input;
}

/*
sts::raw_stdin_byte::raw_stdin_byte() {}

size_t sts::raw_stdin_byte::do_read(byte *b, size_t siz){
	DWORD y;
	if(ReadConsoleW(GetStdHandle(STD_INPUT_HANDLE), b, static_cast<DWORD>(siz/2), &y, NULL) == 0)
		throw IOFail{};
    if(y == 0)
        throw IOEOF{};
	return 2*y;
}

void sts::raw_stdin_byte::do_close() {}

void sts::raw_stdin_byte::do_flush() {
    byte rc[] = {byte{0x0d}, byte{0x00}};
    byte nl[] = {byte{0x0a}, byte{0x00}};
    byte buf[2];
    bool hr=false, hn=false;
    DWORD y;
    do{
        if(ReadConsoleW(GetStdHandle(STD_INPUT_HANDLE), &buf, static_cast<DWORD>(1), &y, NULL) == 0)
            return;
        if(y == 0)
            return;
        if(buf[0] == rc[0] && buf[1] == rc[1])
            hr = true;
        else if(hr && buf[0] == nl[0] && buf[1] == nl[1])
            hn = true;
        else{
            hr = false;
            hn= false;
        }
    }
    while(hr && hn);
}
*/

sts::param_helper::param_helper(int, const char **) : argn{0}, args{nullptr} {
    auto pointer = GetCommandLineW();
    auto ret = CommandLineToArgvW(pointer, &argn);
    args = const_cast<const sts::byte **>(reinterpret_cast<sts::byte **>(ret));
}

sts::param_helper::~param_helper() {
    LocalFree(args);
}

