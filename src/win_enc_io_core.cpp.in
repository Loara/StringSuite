extern "C"{
#include <windows.h>
}
#include <strsuite/io/enc_io_core.hpp>

size_t sts::def_strlen(const byte *b){
    int i = lstrlenW(reinterpret_cast<LPCWSTR>(b));
    if(i >= 0)
        return static_cast<size_t>(i);
    else
        return IOException{};
}

sts::raw_stdin_byte::raw_stdin_byte() {}

size_t sts::raw_stdin_byte::do_read(byte *b, size_t siz){
	DWORD y;
	if(ReadConsoleW(GetStdHandle(STD_INPUT_HANDLE), b, static_cast<DWORD>(siz/2), &y, NULL) == 0)
		throw IOFail{};
    if(y == 0)
        throw IOEOF{};
	return 2*y;
}

void sts::raw_stdin_byte::do_close() {}

void sts::raw_stdin_byte::do_flush() {
    byte rc[] = {byte{0x0d}, byte{0x00}};
    byte nl[] = {byte{0x0a}, byte{0x00}};
    byte buf[2];
    bool hr=false, hn=false;
    DWORD y;
    do{
        if(ReadConsoleW(GetStdHandle(STD_INPUT_HANDLE), &buf, static_cast<DWORD>(1), &y, NULL) == 0)
            return;
        if(y == 0)
            return;
        if(buf[0] == rc[0] && buf[1] == rc[1])
            hr = true;
        else if(hr && buf[0] == nl[0] && buf[1] == nl[1])
            hn = true;
        else{
            hr = false;
            hn= false;
        }
    }
    while(hr && hn);
}

size_t sts::raw_stdout_writebytes(const byte *b, size_t siz){
	DWORD y;
	if(WriteConsoleW(GetStdHandle(STD_OUTPUT_HANDLE), b, static_cast<DWORD>(siz/2), &y, NULL) == 0)
		throw IOException{};
	return 2*y;
}
size_t sts::raw_stderr_writebytes(const byte *b, size_t siz){
	DWORD y;
	if(WriteConsoleW(GetStdHandle(STD_ERROR_HANDLE), b, static_cast<DWORD>(siz/2), &y, NULL) == 0)
		throw IOException{};
	return 2*y;
}

size_t sts::raw_newline(){
    byte ar[] = {byte{0x0d}, byte{0x00}, byte{0x0a}, byte{0x00}};
    return raw_stdout_writebytes(ar, 4);
}

sts::param_helper::param_helper(int, const char **) : argn{0}, args{nullptr} {
    auto pointer = GetCommandLineW();
    auto ret = CommandLineToArgvW(pointer, &argn);
    args = const_cast<const byte **>(reinterpret_cast<byte **>(ret));
}

sts::param_helper::~param_helper() {
    LocalFree(args);
}

