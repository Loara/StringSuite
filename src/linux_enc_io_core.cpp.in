/*
    This file is part of Encmetric.
    Copyright (C) 2021 Paolo De Donato.

    Encmetric is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Encmetric is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with Encmetric. If not, see <http://www.gnu.org/licenses/>.
*/

extern "C"{
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <poll.h>
}
#include <strsuite/io/enc_io_core.hpp>
#include <strsuite/io/enc_io_buffer.hpp>
#include <strsuite/encmetric/enc_c.hpp>

using sts::byte;
using namespace sts::literals;

/*
 * If EWOULDBLOCK != EAGAIN redefine it as case EWOULDBLOCK:
 */

#define case_EWOULDBLOCK

size_t sts::def_strlen(const byte *b){
    return strlen(reinterpret_cast<const char *>(b));
}

struct Linux_syscalls{
    int fd;
    Linux_syscalls(int f) : fd{f} {}

    static constexpr size_t buffer_size=64;
    /*
     * Return must be >0
     * if ==0 then repeat must be true
     */
    size_t read_wrap(byte *v, size_t l, bool &repeat){
        ssize_t wt = read(fd, v, l);
        if(wt < 0){
            switch(errno){
                case EAGAIN:
                case_EWOULDBLOCK
                    throw sts::IOAGAIN{};
                case EINTR:
                    repeat = true;
                    return 0;
                default:
                    throw sts::IOFail{};
            }
        }
        else if(wt == 0)
            throw sts::IOEOF{};
        return static_cast<size_t>(wt);
    }
    size_t write_wrap(const byte *v, size_t l, bool &repeat){
        ssize_t wt = write(fd, v, l);
        if(wt < 0){
            switch(errno){
                case EAGAIN:
                case_EWOULDBLOCK
                    throw sts::IOAGAIN{};
                case EINTR:
                    repeat = true;
                    return 0;
                case EDQUOT:
                case EFBIG:
                    throw sts::IOEOF{};
                default:
                    throw sts::IOFail{};
            }
        }
        else if(wt == 0)
            throw sts::IOEOF{};
        return static_cast<size_t>(wt);
    }
};

class Linux_istream : public sts::NewlineIStream<sts::UTF8>{
    private:
        sts::istr_buffer<sts::UTF8, Linux_syscalls> buffer;
        static_assert(Linux_syscalls::buffer_size > 4, "buffer too small");
    protected:
        sts::adv_string_view<sts::UTF8> do_newline() const noexcept{ return u8"\n"_asv;}
        uint do_char_read(sts::tchar_pt<sts::UTF8> pt, size_t siz){
            if(siz == 0)
                throw sts::IOBufsmall{1};
            uint totl = buffer.get_chLen();
            if(siz < static_cast<size_t>(totl))
                throw sts::IOBufsmall{static_cast<size_t>(totl) - siz};
            std::memcpy(pt.data(), buffer.fir.data(), totl);
            buffer.raw_fir_step(totl);
            return totl;
            /*
            buffer.ghost_copy(pt.data(), 1);
            uint totl = pt.chLen(1);
            if(totl > siz)
                throw sts::IOBufsmall{totl-siz};
            buffer.copy_to(pt.data(), totl);
            return totl;
            */
        }

        uint do_ghost_read(sts::tchar_pt<sts::UTF8> pt, size_t siz){
            if(siz == 0)
                throw sts::IOBufsmall{1};
            uint totl = buffer.get_chLen();
            if(siz < static_cast<size_t>(totl))
                throw sts::IOBufsmall{static_cast<size_t>(totl) - siz};
            std::memcpy(pt.data(), buffer.fir.data(), totl);
            return totl;
            /*
            if(siz == 0)
                throw sts::IOBufsmall{1};
            buffer.ghost_copy(pt.data(), 1);
            uint totl = pt.chLen(1);
            if(totl > siz)
                throw sts::IOBufsmall{totl-siz};
            buffer.ghost_copy(pt.data(), totl);
            return totl;
            */
        }

        void do_close() {}

        void do_flush(){
            pollfd readany{};
            while(true){
                readany.fd = buffer.get_system_id().fd;
                readany.events = POLLIN;//test if there is any remaining byte to read
                int err = poll(&readany, 1, 0);
                if(err == -1 || (readany.revents & POLLIN) == 0){
                    //No data to read
                    break;
                }
                byte chr[4];
                sts::tchar_pt<sts::UTF8> o{chr};
                do{
                    try{
                        do_char_read(o, 4);
                    }
                    catch(...){
                        return;
                    }
                }
                while(chr[0] != byte{'\n'});
            }
        }

        sts::EncMetric_info<sts::UTF8> do_encmetric() const noexcept{ return sts::EncMetric_info<sts::UTF8>{};}
    public:
        Linux_istream () : buffer{Linux_syscalls{STDIN_FILENO}} {}
};

class Linux_ostream : public sts::NewlineOStream<sts::UTF8>{
    private:
        sts::ostr_buffer<sts::UTF8, Linux_syscalls> buffer;
        static_assert(Linux_syscalls::buffer_size > 4, "buffer too small");
    protected:
        sts::adv_string_view<sts::UTF8> do_newline() const noexcept{ return u8"\n"_asv;}
        uint do_char_write(sts::const_tchar_pt<sts::UTF8> pt, size_t siz){
            if(siz == 0)
                throw sts::IOBufsmall{1};
            uint totl = pt.chLen(siz);
            if(totl > siz)
                throw sts::IOBufsmall{totl-siz};
            buffer.force_frspc(totl);
            std::memcpy(buffer.las.data(), pt.data(), totl);
            buffer.raw_las_step(totl);
            return totl;
        }
        size_t do_string_write(const sts::adv_string_view<sts::UTF8> &str){
            size_t rem = str.size();
            const byte *b = str.data();
            while(rem > 0){
                size_t wrt = buffer.req_frspc(rem);
                std::memcpy(buffer.las.data(), b, wrt);
                buffer.raw_las_step(wrt);
                rem -= wrt;
            }
            return str.size();
        }

        void do_close() {}

        void do_flush(){
            buffer.flush();
        }

        sts::EncMetric_info<sts::UTF8> do_encmetric() const noexcept{ return sts::EncMetric_info<sts::UTF8>{};}
    public:
        Linux_ostream (int f) : buffer{Linux_syscalls{f}} {}
};

sts::NewlineIStream<sts::UTF8> &sts::get_console_stdin(){
    static Linux_istream input{};
    return input;
}

sts::NewlineOStream<sts::UTF8> &sts::get_console_stdout(){
    static Linux_ostream input{STDOUT_FILENO};
    return input;
}

sts::NewlineOStream<sts::UTF8> &sts::get_console_stderr(){
    static Linux_ostream input{STDERR_FILENO};
    return input;
}

sts::param_helper::param_helper(int n, const char **c) : argn{n}, args{reinterpret_cast<const byte **>(c)} {}

sts::param_helper::~param_helper() {}

