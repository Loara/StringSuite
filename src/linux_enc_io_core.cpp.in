extern "C"{
#include <unistd.h>
#include <stdio.h>
#include <string.h>
}
#include <strsuite/io/enc_io_core.hpp>
#include <strsuite/encmetric/enc_c.hpp>

using sts::byte;
using namespace sts::literals;

/*
 * If EWOULDBLOCK != EAGAIN redefine it as case EWOULDBLOCK:
 */
#define case_EWOULDBLOCK

constexpr size_t buffer_size=64;

static_assert(buffer_size > sts::UTF8::max_bytes(), "buffer too small");

size_t sts::def_strlen(const byte *b){
    return strlen(reinterpret_cast<const char *>(b));
}

ssize_t read_wrap(int fd, void *v, size_t l){
    return read(fd, v, l);
}

ssize_t write_wrap(int fd, const void *v, size_t l){
    return write(fd, v, l);
}
class in_buffer{
    private:
        int fd;
        byte buf[buffer_size];
        size_t siz, fir;
        void refresh(){
            fir=0;
            siz=0;
        }
        void fill(){
            ssize_t wt;
            bool repeat;
            do{
                repeat=false;
                wt= read_wrap(fd, buf + siz, buffer_size - siz);
                if(wt < 0){
                    switch(errno){
                        case EAGAIN:
                        case_EWOULDBLOCK
                            throw sts::IOAGAIN{};
                        case EINTR:
                            repeat = true;
                            break;
                        default:
                            throw sts::IOFail{};
                    }
                }
                else if(wt == 0)
                    throw sts::IOEOF{};
            }while(repeat);
            siz += static_cast<size_t>(wt);
        }
        void shift(size_t &tmp){
            if(fir == 0)
                return;
            siz = siz - fir;
            tmp = tmp - fir;
            std::memmove(buf, buf + fir, siz);
            fir = 0;
        }
    public:
        /*
         * Read exactly len bytes, throw exception (IOEOF for example) if there are less
         *
         * Since it reads only single character we have len <= 4
         * so tmp - fir <= 4 and if siz = tmp then
         * buffer_size > 4 >= siz - fir and  buffer_size - (siz - fir) > 0, this implies that shift + fill will read at least 1 byte
         */
        void copy_to(byte *to, size_t len){
            size_t tmp = fir;
            byte *inc = to;
            while(len > 0){
                size_t buf_wrt = siz - tmp;
                if(buf_wrt > 0){
                    size_t min = buf_wrt > len ? len : buf_wrt;
                    std::memcpy(inc, buf + tmp, min);
                    tmp += min;
                    inc += min;
                    len -= min;
                }
                else{
                    shift(tmp);
                    fill();
                }
            }
            fir = tmp;
        }
        void ghost_copy(byte *to, size_t len){
            size_t tmp = fir;
            byte *inc = to;
            while(len > 0){
                size_t buf_wrt = siz - tmp;
                if(buf_wrt > 0){
                    size_t min = buf_wrt > len ? len : buf_wrt;
                    std::memcpy(inc, buf + tmp, min);
                    tmp += min;
                    inc += min;
                    len -= min;
                }
                else{
                    shift(tmp);
                    fill();
                }
            }
            //Nope
            //fir = tmp;
        }

        in_buffer(int f) : fd{f} {}
};

class out_buffer{
    private:
        int fd;
        byte buf[buffer_size];
        size_t pt1, pt2; // 0 < pt1 < pt2 < tmp < buffer_size
        void refresh(){
            pt1=0;
            pt2=0;
        }
        void push(){
            ssize_t wt;
            bool repeat;
            do{
                repeat=false;
                wt= write_wrap(fd, buf + pt1, pt2 - pt1);
                if(wt < 0){
                    switch(errno){
                        case EAGAIN:
                        case_EWOULDBLOCK
                            throw sts::IOAGAIN{};
                        case EINTR:
                            repeat = true;
                            break;
                        case EDQUOT:
                        case EFBIG:
                            throw sts::IOEOF{};
                        default:
                            throw sts::IOFail{};
                    }
                }
                else if(wt == 0)
                    throw sts::IOEOF{};
            }while(repeat);
            pt1 += static_cast<size_t>(wt);
        }
        void shift(){
            std::memmove(buf, buf + pt1, pt2 - pt1);
            pt2 = pt2 - pt1;
            pt1 = 0;
        }
    public:
        void copy_from(const byte *from, size_t len){
            const byte *inc = from;
            while(len > 0){
                size_t buf_wrt = buffer_size - pt2;
                if(buf_wrt > 0){
                    size_t min = buf_wrt > len ? len : buf_wrt;
                    std::memcpy(buf+pt2, inc, min);
                    pt2 += min;
                    inc += min;
                    len -= min;
                }
                else{
                    push();
                    shift();
                    //pt1 will always be 0
                }
            }
        }

        void flush(){
            while(true){
                shift();
                if(pt2 == 0)
                    break;
                push();
            }
        }

        out_buffer(int f) : fd{f} {}
};

class Linux_istream : public sts::NewlineIStream<sts::UTF8>{
    private:
        in_buffer buffer;
    protected:
        sts::adv_string_view<sts::UTF8> do_newline() const noexcept{ return u8"\n"_asv;}
        uint do_char_read(sts::tchar_pt<sts::UTF8> pt, size_t siz){
            if(siz == 0)
                throw sts::IOBufsmall{1};
            buffer.ghost_copy(pt.data(), 1);
            uint totl = pt.chLen(1);
            if(totl > siz)
                throw sts::IOBufsmall{totl-siz};
            buffer.copy_to(pt.data(), totl);
            return totl;
        }

        uint do_ghost_read(sts::tchar_pt<sts::UTF8> pt, size_t siz){
            if(siz == 0)
                throw sts::IOBufsmall{1};
            buffer.ghost_copy(pt.data(), 1);
            uint totl = pt.chLen(1);
            if(totl > siz)
                throw sts::IOBufsmall{totl-siz};
            buffer.ghost_copy(pt.data(), totl);
            return totl;
        }

        void do_close() {}

        void do_flush(){
            byte chr[4];
            sts::tchar_pt<sts::UTF8> o{chr};
            do{
                try{
                    do_char_read(o, 4);
                }
                catch(...){
                    return;
                }
            }
            while(chr[0] != byte{'\n'});
        }

        sts::EncMetric_info<sts::UTF8> do_encmetric() const noexcept{ return sts::EncMetric_info<sts::UTF8>{};}
    public:
        Linux_istream () : buffer{STDIN_FILENO} {}
};

class Linux_ostream : public sts::NewlineOStream<sts::UTF8>{
    private:
        out_buffer buffer;
    protected:
        sts::adv_string_view<sts::UTF8> do_newline() const noexcept{ return u8"\n"_asv;}
        uint do_char_write(sts::const_tchar_pt<sts::UTF8> pt, size_t siz){
            if(siz == 0)
                throw sts::IOBufsmall{1};
            uint totl = pt.chLen(siz);
            if(totl > siz)
                throw sts::IOBufsmall{totl-siz};
            buffer.copy_from(pt.data(), totl);
            return totl;
        }
        size_t do_string_write(sts::adv_string_view<sts::UTF8> &str){
            buffer.copy_from(str.data(), str.size());
            return str.size();
        }

        void do_close() {}

        void do_flush(){
            buffer.flush();
        }

        sts::EncMetric_info<sts::UTF8> do_encmetric() const noexcept{ return sts::EncMetric_info<sts::UTF8>{};}
    public:
        Linux_ostream (int f) : buffer{f} {}
};

sts::NewlineIStream<sts::UTF8> *sts::get_console_stdin(){
    static Linux_istream input{};
    return &input;
}

sts::NewlineOStream<sts::UTF8> *sts::get_console_stdout(){
    static Linux_ostream input{STDOUT_FILENO};
    return &input;
}

sts::NewlineOStream<sts::UTF8> *sts::get_console_stderr(){
    static Linux_ostream input{STDERR_FILENO};
    return &input;
}

sts::param_helper::param_helper(int n, const char **c) : argn{n}, args{reinterpret_cast<const byte **>(c)} {}

sts::param_helper::~param_helper() {}

