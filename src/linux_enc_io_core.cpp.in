extern "C"{
#include <unistd.h>
#include <stdio.h>
#include <string.h>
}
#include <strsuite/io/enc_io_core.hpp>

size_t sts::def_strlen(const byte *b){
    return strlen(reinterpret_cast<const char *>(b));
}

ssize_t read_wrap(int fd, void *v, size_t l){
    return read(fd, v, l);
}

sts::raw_stdin_byte::raw_stdin_byte() {}

size_t sts::raw_stdin_byte::do_read(byte *b, size_t siz){
	ssize_t tret = read_wrap(STDIN_FILENO, b, siz);
	if(tret < 0){
        if(errno == EAGAIN || errno == EWOULDBLOCK)
            throw IOAGAIN{};
        else
            throw IOFail{};
	}
	else if(tret == 0)
        throw IOEOF{};
	return static_cast<size_t>(tret);
}

void sts::raw_stdin_byte::do_close() {}

void sts::raw_stdin_byte::do_flush() {
    byte chr;
    do{
        auto r = read_wrap(STDIN_FILENO, &chr, 1);
        if(r <= 0)
            return;
    }
    while(chr != byte{'\n'});
}

size_t sts::raw_stdout_writebytes(const byte *b, size_t siz){
	ssize_t tret = write(STDOUT_FILENO, b, siz);
	if(tret < 0)
        throw IOException{};
    return static_cast<size_t>(tret);
}
size_t sts::raw_stderr_writebytes(const byte *b, size_t siz){
	ssize_t tret = write(STDERR_FILENO, b, siz);
	if(tret < 0)
        throw IOException{};
    return static_cast<size_t>(tret);
}

size_t sts::raw_newline(){
    byte ar[] = {byte{0x0a}};
    return raw_stdout_writebytes(ar, 1);
}

sts::param_helper::param_helper(int n, const char **c) : argn{n}, args{reinterpret_cast<const byte **>(c)} {}

sts::param_helper::~param_helper() {}

